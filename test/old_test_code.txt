#Test with a real image
atoms = 5
reference = io.imread('castle.jpg', as_gray=True).astype(float)
height, width = reference.shape
patch_size = (7, 7)
split_part = 4

#add noise
noise = 0.200
distorted = reference.copy()
distorted[:, :width // split_part ] += noise * np.random.randn(height, width // split_part)
plt.imshow(distorted,cmap='gray')
plt.show()

data = image.extract_patches_2d(distorted[:, :width // split_part ], patch_size)
data = data.reshape(data.shape[0], -1)
data -= np.mean(data, axis=0) # normalization
data /= np.std(data, axis=0) # standardizing
D = np.matrix(np.random.rand(np.shape(data)[0],atoms))

amount = 10  #Samples of atoms for each class; K = len(classes)*amount
signals = 20 #Samples in Y
M = 10000
S = signals			#Same as in paper
K = np.shape(D)[1]  #Same as in paper 
ddim = np.shape(D)[0]

tD = 5 #cloud KSVD iterations
t0 = 5 #sparsity
tc = 2 #consensus iterations
tp = 2 #power iterations

nodes = 1
weights = np.zeros(nodes) #the weights for nodes, number if nodes is 1
refvec = np.matrix(np.ones((ddim,1))) #Q_init for power method, sets direction of result
Tag = 11			  #Transmission tag, ensures MPI transmissions don't interfere
CorrectiveSpacing = 3 #Regular iterations before a corrective iteration
timeOut = 0.150		  #Time nodes wait before they move on

#run ksvd
D,X,rerror = CloudKSVD(D,np.asmatrix(data),refvec,tD,t0,tc,tp,weights,Tag,CorrectiveSpacing,timeOut)
error = np.linalg.norm(data-np.dot(D,X))**2 #L2 norm squared for error
print('Error with CK-SVD dictionary: %.2f' % (error))

#make a random dictionary for comparison
Dr = np.matrix(np.random.rand(np.shape(data)[0],atoms))
error = np.linalg.norm(data-np.dot(Dr,X))**2 #L2 norm squared for error
print('Error with a random dictionary: %.2f' % (error))

#do reconstruction of the image that was used as patches, see split_part
Y = np.dot(np.array(D),np.array(X))
Y += np.mean(data, axis=0)
Y = Y.reshape(len(data), *patch_size)
result = reconstruct_from_patches_2d(Y, (height, width // split_part))
plt.imshow(result,cmap='gray')
plt.show()

#difference between org and noisy
difference = distorted[:, :width // split_part ] - reference[:, :width // split_part ]
print('Difference for distorted (norm: %.2f)' % np.sqrt(np.sum(difference ** 2)))

#difference between org and reconstructed
difference = result - reference[:, :width // split_part ]
print('Difference for result (norm: %.2f)' % np.sqrt(np.sum(difference ** 2)))